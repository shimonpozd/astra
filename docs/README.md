# Документация по API сервиса `brain`

Этот документ описывает, как фронтенд-клиентам взаимодействовать с API сервиса `brain`.

## 1. Ключевые концепции

### Единый эндпоинт для чата
Все чат-взаимодействия, как обычные сообщения, так и сложные команды, происходят через **один** эндпоинт: `POST /chat/stream`.

### Режимы работы
Сервис имеет два основных режима, которые определяются текстом вашего запроса:
1.  **Обычный чат:** Стандартный диалог с ассистентом.
2.  **Режим исследования:** Запускается, если текст сообщения начинается с команды `/research`. Этот режим предназначен для глубокого анализа источников и возвращает более структурированный поток данных.

### Потоковая передача (NDJSON)
Ответ от `/chat/stream` всегда является потоковым. Бэкенд отправляет последовательность JSON-объектов, разделенных символом новой строки (`\n`). Этот формат называется **NDJSON**.

**Исключение:** В режиме **обычного чата** для создания эффекта "печатающейся машинки" бэкенд сначала отправляет "сырые" куски текста, и только в конце — финальный JSON-объект.

## 2. Справочник по API

### Эндпоинты

*   `POST /chat/stream`
    *   **Назначение:** Основной эндпоинт для всех чат-взаимодействий.
    *   **Тело запроса:** `ChatRequest` (см. ниже).
    *   **Ответ:** Поток NDJSON.

*   `GET /chats`
    *   **Назначение:** Получить список всех сохраненных чат-сессий.

*   `GET /chats/{session_id}`
    *   **Назначение:** Получить историю сообщений для конкретной сессии.

*   `GET /health`
    *   **Назначение:** Проверка работоспособности сервиса.

### Тело запроса: `ChatRequest`

| Поле | Тип | Обязательность | Описание |
| :--- | :--- | :--- | :--- |
| `text` | string | **Да** | Текст сообщения пользователя. |
| `user_id` | string | **Да** | Постоянный уникальный идентификатор пользователя. |
| `session_id` | string | Нет | ID текущей сессии. Если не указан, создается новая сессия. |
| `agent_id` | string | Нет | ID "личности" ассистента. По умолчанию: `"default"`.

**Пример:**
```json
{
  "text": "/research Shulchan Arukh, Orach Chayim 252:1",
  "user_id": "web_user_persistent_id",
  "session_id": "c583d623-a2b3-4f3c-9c94-881b1cc21f14",
  "agent_id": "chevruta_deepresearch"
}
```

### Поток ответа (NDJSON)

#### Режим исследования (`/research`)
В этом режиме все сообщения являются JSON-объектами вида `{"type": "...", "data": {...}}`.

*   **Основные типы событий:**
    *   `status`: Сообщение о текущем статусе процесса.
    *   `plan`: Сгенерированный план исследования.
    *   `source`: **(Ключевое событие)** Данные о найденном источнике.
    *   `note_created`: Уведомление о создании заметки по источнику.
    *   `draft` / `final_draft`: Сгенерированный черновик или финальный ответ.

*   **Пример события `source`:**
    ```json
    {
      "type": "source",
      "data": {
        "id": "source-a1b2c3d4-...",
        "author": "Rashi",
        "book": "Genesis",
        "reference": "Rashi on Genesis 1:1",
        "text": "In the beginning...",
        "url": "https://sefaria.org/Rashi_on_Genesis.1.1",
        "ui_color": "#ff7f0e",
        "lang": "en",
        "heRef": "רש"י על בראשית א:א"
      }
    }
    ```

#### Обычный чат
Поток является смешанным:

1.  **Сначала:** Несколько сообщений с "сырым" текстом (не JSON).
2.  **В конце:** Одно финальное JSON-событие.

*   **Пример потока:**
    ```
    Привет,
     как я могу
     помочь?
    {"type": "draft", "data": {"draft": "Привет, как я могу помочь?", "flow": "conversational"}}
    ```

## 3. Важные детали

### Управление сессиями
*   **Чтобы создать новый чат**, не передавайте поле `session_id` в запросе.
*   **Чтобы продолжить существующий чат**, передайте его `session_id`.

### Идентификация пользователя (`user_id`)
*   `user_id` — это **обязательное** поле.
*   Для корректной работы истории чатов и других функций `user_id` должен быть **постоянным** для каждого пользователя. Клиент (фронтенд) должен сгенерировать его один раз при первом входе пользователя и сохранить (например, в `localStorage`) для всех последующих запросов.

### Аутентификация
*   На данный момент стандартная аутентификация (по токенам) отсутствует.
*   Вся логика разделения данных построена на `user_id`. API доверяет клиенту и ожидает, что он будет передавать корректный `user_id`.

## 4. Пример кода для фронтенда

Эта функция показывает, как отправить сообщение и обработать смешанный поток ответа в режиме обычного чата.

```javascript
async function sendMessageAndDisplayResponse(messageText) {
  const responseContainer = document.getElementById('assistant-response');
  responseContainer.innerText = ""; // Очищаем предыдущий ответ

  const response = await fetch('http://localhost:7030/chat/stream', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      text: messageText,
      user_id: 'web_user_persistent_id', // Должен быть постоянным!
      agent_id: 'default'
    })
  });

  const reader = response.body.getReader();
  const decoder = new TextDecoder();
  let buffer = ''; // Буфер для хранения неполных сообщений

  while (true) {
    const { value, done } = await reader.read();
    if (done) break; // Поток завершен

    buffer += decoder.decode(value, { stream: true });
    const lines = buffer.split('\n');
    buffer = lines.pop(); // Последняя строка может быть неполной

    for (const line of lines) {
      if (!line.trim()) continue;

      try {
        // Пытаемся понять, является ли строка JSON-объектом
        const event = JSON.parse(line);

        // Если это JSON и у него есть тип 'draft' - это финальный сигнал
        if (event.type === 'draft' && event.data.draft) {
          console.log("Финальный полный ответ:", event.data.draft);
          responseContainer.innerText = event.data.draft;
        }
      } catch (error) {
        // Если это не JSON - значит, это просто кусок текста
        const textChunk = line;
        console.log("Получен кусок текста:", textChunk);
        responseContainer.innerText += textChunk;
      }
    }
  }
  
  // Обрабатываем остаток в буфере
  if (buffer.trim()) {
      responseContainer.innerText += buffer;
  }
}
