# ТЗ для фронтенда: поддержка `doc.v1` и потоковых ответов

## Цели
1. Полностью перевести пользовательский и study-чаты на работу с `doc.v1`-структурой.
2. Обеспечить корректный рендеринг, хранение и повторное воспроизведение структурированных сообщений.
3. Подготовить клиента к будущему стримингу частичных блоков и действиям (`ops`).

## Область работ
- **Компонентный слой**: ChatViewport, MessageRenderer, StudyMode, BrainChat, ResearchFeed при просмотре истории.
- **Сервисный слой**: `src/services/api.ts`, `src/hooks/useChat.ts`, `src/hooks/useStudyMode.ts`.
- **Типы/модели**: `src/types/text.ts`, `src/types/chat.ts`, `src/types/index.ts`.

## Требования

### 1. Типы и хранилище
- Использовать `Message` тип, позволяющий `content: string | DocV1 | null` и поле `content_type` (`'text.v1' | 'doc.v1'`).
- При стриминге:
  - `onChunk` → аппендить текст в строковом `content`, оставляя `content_type: 'text.v1'`.
  - `onDoc` → заменять `content` на `DocV1`, выставлять `content_type: 'doc.v1'`.
  - По завершении стрима оставлять итоговое состояние сообщения (без переинициализации массивов).
- Исторические загрузки (`getChatHistory`) должны возвращать массив `Message[]` с уже готовыми `DocV1` (не сериализованной строкой).

### 2. Рендеринг (`MessageRenderer`)
- Поддерживать все блоки, описанные в `docs/doc_v1_format.md`.
- RTL/языковые атрибуты: применять `lang` и `dir` к текстовым блокам.
- md-lite: обработать `**bold**`, `*italic*`, `` `code` ``, `[link](url)` (без допуска HTML).
- Ивент для `action`-блоков: выбрасывать `window.dispatchEvent(new CustomEvent('doc-action', { detail: block }))`.
- Unknown-тип → лог + graceful fallback (рендер `JSON.stringify(content)` в `paragraph`).

### 3. Компоненты чата
- `ChatViewport`: оперировать коллекцией `Message[]`. Не полагаться на отдельные `ChatMessage` DTO.
- `StudyMode`: после стрима обновлять `Message` в списке (избегать дублей), синхронизировать `content_type`.
- `BrainChat`/`ResearchFeed`: поддержка отображения новых блоков при загрузке истории.

### 4. Стриминг API (`src/services/api.ts`)
- Универсальный обработчик `StreamHandler`:
  - `onEvent(event)` – опционален для логирования.
  - `onChunk(chunk: string)` – текстовые дельты.
  - `onDoc(doc: DocV1)` – финальный документ.
  - `onError(error)` – оборачивать в `Error` и сигнализировать UI.
  - `onComplete()` – закрытие стрима.
- Разбор NDJSON: JSON строки формата `{ "type": "llm_chunk", ... }`. Конвертировать в вызовы колбеков.

### 5. UX
- Плавная прокрутка до последнего блока при стриме (`scrollIntoView`).
- Индикатор загрузки, пока `content_type` не определён (можно показывать “Генерация...” вместо пустоты).
- Ошибки в стриме: отображать в том же сообщении (`Error: ...`).

### 6. Тестирование
- Snapshot тесты на уровне React компонентов для разных блоков (`quote`, `term`, `callout` и т.д.).
- Юнит-тест на парсер md-lite (`Paragraph` → html).
- Интеграционный тест: симуляция стрима (последовательность chunk → doc) и проверка итогового массива сообщений.

### 7. Логи и метрики
- Логировать в dev-режиме предупреждения о неизвестных блоках и невалидных doc (`console.warn`).
- (опционально) добавить счётчик/метку в Sentry или аналогичный трекер при ошибках парсинга.

## Не входит в объём
- Реализация UI-редактора для ops или новых действий.
- Хранение истории doc.v1 в браузерном оффлайн-кэше.
- Визуализация audit trail/ops.

## Документация
- Основная спецификация структуры: `docs/doc_v1_format.md`.
- Для QA: добавить примеры payload в Postman коллекцию (`docs/doc_v1_samples.json`).

## Дальнейшие шаги
1. Обновить типы и сервисы.
2. Переписать `MessageRenderer` согласно спецификации.
3. Настроить Storybook/Playwright сценарий с doc.v1 примерами (если Storybook используется).
4. Обновить пользовательскую документацию/FAQ (как читаются структурированные ответы).

